<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Suika Final + Sprites</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #dedede;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            /* background: #fffbe6; */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
        }
		
		#game-container::before {
			content: "";
			position: absolute;
			top: 0; left: 0; right: 0; bottom: 0;
			
			/* Sua imagem aqui */
			background-image: url('img/bg.png');
			background-size: cover;
			background-position: center;
			
			/* 泙 Truque: Opacidade para ficar suave (0.3 = 30% visﾃｭvel) */
			opacity: 0.3; 
			
			z-index: -1; /* Fica atrﾃ｡s de tudo */
		}

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 12px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        #ui-label { font-size: 10px; color: #555; font-weight: 800; letter-spacing: 0.5px; }

        /* Ajuste para mostrar a imagem na UI de "Prﾃｳximo" */
        #next-fruit-display {
            width: 35px;
            height: 35px;
            margin-top: 5px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        #score-board {
            position: absolute;
            top: 15px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        #score-label { font-size: 11px; color: #999; font-weight: bold; display: block; }
        #score-val { font-size: 36px; font-weight: 900; color: #444; line-height: 1; text-shadow: 2px 2px 0 #fff; }

        #game-over {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30,30,30,0.96);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #game-over button {
            margin-top: 25px;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: #ffcc00;
            color: #222;
            border: none;
            border-radius: 50px;
            text-transform: uppercase;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <div id="game-container">
        <div id="score-board">
            <span id="score-label">SCORE</span>
            <span id="score-val">0</span>
        </div>

        <div id="ui-layer">
            <span id="ui-label">NEXT</span>
            <div id="next-fruit-display"></div>
        </div>

        <div id="game-over">
            <h1 style="font-size:3rem; margin: 0 0 10px 0">GAME OVER</h1>
            <p id="final-score" style="font-size: 1.5rem; color: #aaa;">Score: 0</p>
            <button onclick="location.reload()">Reiniciar</button>
        </div>
    </div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          World = Matter.World,
          Body = Matter.Body;

    // --- CONFIGURAﾃﾃグ ---
    const LOGICAL_WIDTH = 360;  
    const LOGICAL_HEIGHT = 640; 
    const ASPECT_RATIO = LOGICAL_WIDTH / LOGICAL_HEIGHT;
    
    const WALL_THICKNESS = 2000; 
    const FLOOR_OFFSET = 30; 
    const DEADLINE_Y = 130;

    // 泙 CONFIGURAﾃﾃグ DE IMAGEM
    // Defina aqui o tamanho em pixels das suas imagens originais (ex: 512x512)
    const ART_SIZE = 512; 
    
    // Caminho base das imagens (pode deixar vazio se estiverem na mesma pasta)
    const IMG_PATH = 'img/'; 

    const FRUITS = [
        // img: Nome do arquivo dentro da pasta img/
        { r: 16, color: '#F00', score: 2,  img: 'fruit_0.png' },
        { r: 24, color: '#F55', score: 4,  img: 'fruit_1.png' },
        { r: 32, color: '#A0A', score: 6,  img: 'fruit_2.png' },
        { r: 38, color: '#FA0', score: 8,  img: 'fruit_3.png' },
        { r: 46, color: '#F80', score: 10, img: 'fruit_4.png' },
        { r: 58, color: '#F00', score: 12, img: 'fruit_5.png' },
        { r: 70, color: '#ED0', score: 14, img: 'fruit_6.png' },
        { r: 84, color: '#FB8', score: 16, img: 'fruit_7.png' },
        { r: 98, color: '#FF0', score: 18, img: 'fruit_8.png' },
        { r: 112,color: '#0F0', score: 20, img: 'fruit_9.png' },
        { r: 126,color: '#080', score: 22, img: 'fruit_10.png'}
    ];

    let score = 0;
    let dangerCounter = 0;
    const scoreEl = document.getElementById('score-val');
    const finalScoreEl = document.getElementById('final-score');
    const nextDisplay = document.getElementById('next-fruit-display');
    const container = document.getElementById('game-container');

    // --- RESIZE ---
    function resizeGame() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const winRatio = winW / winH;
        let newWidth, newHeight;
        if (winRatio > ASPECT_RATIO) {
            newHeight = Math.min(winH, 800);
            if(winH < 800) newHeight = winH;
            newWidth = newHeight * ASPECT_RATIO;
        } else {
            newWidth = winW;
            newHeight = newWidth / ASPECT_RATIO;
        }
        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
    }
    window.addEventListener('resize', resizeGame);
    resizeGame();

    // --- SETUP ENGINE ---
    const engine = Engine.create({
        positionIterations: 16,
        velocityIterations: 16,
        constraintIterations: 4,
        enableSleeping: false 
    });
    const world = engine.world;

    const render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: LOGICAL_WIDTH,
            height: LOGICAL_HEIGHT,
            wireframes: false, // Importante: false para ver as imagens!
            background: 'transparent',
            pixelRatio: 1.5
        }
    });

    // --- MUNDO (PAREDES) ---
    const floorY = LOGICAL_HEIGHT + (WALL_THICKNESS / 2) - FLOOR_OFFSET;
    
    const ground = Bodies.rectangle(LOGICAL_WIDTH/2, floorY, LOGICAL_WIDTH + 200, WALL_THICKNESS, { 
        isStatic: true, 
        render: { fillStyle: '#8d6e63' },
        friction: 0.8,      
        frictionStatic: 10,
        restitution: 0.0,   
        label: "ground"
    });
    
    const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, render: {fillStyle: '#8d6e63'}, friction: 0.2, restitution: 0.0 
    });
    const rightWall = Bodies.rectangle(LOGICAL_WIDTH + WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, render: {fillStyle: '#8d6e63'}, friction: 0.2, restitution: 0.0 
    });

    World.add(world, [ground, leftWall, rightWall]);

    // --- VISUAIS (Linhas) ---
    Events.on(render, 'afterRender', function() {
        const ctx = render.context;
        
        // Linha de Mira
        if (currentBody && canDrop && !gameOverState) {
            ctx.beginPath();
            ctx.moveTo(currentBody.position.x, currentBody.position.y);
            ctx.lineTo(currentBody.position.x, LOGICAL_HEIGHT - FLOOR_OFFSET);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
        }

        // Linha da Morte
        ctx.beginPath();
        ctx.moveTo(0, DEADLINE_Y);
        ctx.lineTo(LOGICAL_WIDTH, DEADLINE_Y);
        
        if (dangerCounter > 0) {
            const pulse = Math.sin(engine.timing.timestamp * 0.015); 
            const alpha = 0.7 + pulse * 0.3;
            const thickness = 4 + pulse * 1;

            ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
            ctx.lineWidth = thickness;
            ctx.setLineDash([12, 8]); 
            ctx.shadowColor = 'red';
            ctx.shadowBlur = 10;
        } else {
            ctx.strokeStyle = 'rgba(255, 69, 0, 0.4)';
            ctx.lineWidth = 3;
            ctx.setLineDash([12, 10]);
            ctx.shadowBlur = 0;
        }
        
        ctx.stroke();
        ctx.shadowBlur = 0;
    });

    // --- CRIAﾃﾃグ DE FRUTAS (COM SPRITES) ---
    function createFruit(x, y, tier, isStatic = false) {
        const cfg = FRUITS[tier];
        
        // 泙 Cﾃ｡lculo Automﾃ｡tico da Escala da Imagem
        // O diﾃ｢metro no jogo ﾃｩ (cfg.r * 2).
        // A escala ﾃｩ: (TamanhoDesejado / TamanhoOriginalDaImagem)
        const scale = (cfg.r * 2) / ART_SIZE;

        const body = Bodies.circle(x, y, cfg.r, {
            label: tier.toString(),
            isStatic: isStatic,
            restitution: 0.05,
            friction: 0.3,
            frictionAir: 0.02,
            density: 0.0015,
            render: { 
                // Se o arquivo da imagem nﾃ｣o existir, ele usa o fillStyle como backup
                fillStyle: cfg.color,
                sprite: {
                    texture: IMG_PATH + cfg.img,
                    xScale: scale,
                    yScale: scale
                }
            }
        });

        if (isStatic) {
            body.isInvulnerable = true;
        }
        return body;
    }

    function createMergeEffect(x, y, color) {
        // Mantemos partﾃｭculas coloridas pois imagens de partﾃｭculas podem pesar
        for (let i = 0; i < 8; i++) {
            const particle = Bodies.circle(x, y, 5, {
                render: { fillStyle: color },
                isSensor: true,
                frictionAir: 0.05
            });
            const angle = Math.random() * Math.PI * 2;
            const speed = 4 + Math.random()*4;
            Body.setVelocity(particle, { x: Math.cos(angle)*speed, y: Math.sin(angle)*speed });
            World.add(world, particle);
            setTimeout(() => World.remove(world, particle), 450);
        }
    }

    // --- GAME LOOP ---
    let currentBody = null;
    let nextTier = 0;
    let canDrop = true;
    let gameOverState = false;

    function pickNextTier() {
        let maxOnField = 0;
        Composite.allBodies(world).forEach(b => {
            if (!b.isStatic && parseInt(b.label) >= 0) maxOnField = Math.max(maxOnField, parseInt(b.label));
        });
        let maxSpawn = 0;
        if (maxOnField >= 2) maxSpawn = 1;
        if (maxOnField >= 4) maxSpawn = 2;
        if (maxOnField >= 6) maxSpawn = 3;

        let pool = [];
        for(let i=0; i <= maxSpawn; i++) {
            for(let k=0; k < 3; k++) pool.push(i);
        }
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function spawnNext() {
        if (gameOverState) return;
        const tier = nextTier;
        nextTier = pickNextTier();
        
        // 泙 Atualiza a UI com a imagem
        nextDisplay.style.backgroundColor = 'transparent'; // Remove cor de fundo
        nextDisplay.style.backgroundImage = `url(${IMG_PATH + FRUITS[nextTier].img})`;
        
        currentBody = createFruit(LOGICAL_WIDTH / 2, 50, tier, true);
        World.add(world, currentBody);
        canDrop = true;
    }

    // --- INPUT ---
    function handleInput(clientX) {
        if (!currentBody || !canDrop || gameOverState) return;
        const rect = render.canvas.getBoundingClientRect();
        const scale = LOGICAL_WIDTH / rect.width;
        let x = (clientX - rect.left) * scale;
        const r = currentBody.circleRadius;
        if (x < r) x = r;
        if (x > LOGICAL_WIDTH - r) x = LOGICAL_WIDTH - r;
        Body.setPosition(currentBody, { x: x, y: 50 });
    }

    function handleRelease() {
        if (!currentBody || !canDrop || gameOverState) return;
        canDrop = false;
        Body.setStatic(currentBody, false);
        currentBody = null;
        setTimeout(spawnNext, 500);
    }

    container.addEventListener('mousemove', e => handleInput(e.clientX));
    container.addEventListener('mouseup', handleRelease);
    container.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
    container.addEventListener('touchend', handleRelease);

    // --- COLISﾃグ ---
    Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        const processed = new Set(); 

        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA;
            const bodyB = pairs[i].bodyB;
            
            const id = bodyA.id < bodyB.id ? `${bodyA.id}-${bodyB.id}` : `${bodyB.id}-${bodyA.id}`;
            if (processed.has(id)) continue;
            processed.add(id);

            if (bodyA.label === bodyB.label && !bodyA.isStatic && !bodyB.isStatic) {
                const tier = parseInt(bodyA.label);
                score += FRUITS[tier].score;
                scoreEl.innerText = score;

                if (tier < FRUITS.length - 1) {
                    let newX = (bodyA.position.x + bodyB.position.x) / 2;
                    let newY = (bodyA.position.y + bodyB.position.y) / 2;
                    
                    World.remove(world, [bodyA, bodyB]);

                    const nextTierIdx = tier + 1;
                    const finalRadius = FRUITS[nextTierIdx].r;
                    
                    // Clamp
                    const floorYVisual = LOGICAL_HEIGHT - FLOOR_OFFSET;
                    if (newY + finalRadius > floorYVisual) newY = floorYVisual - finalRadius;
                    if (newX - finalRadius < 0) newX = finalRadius;
                    if (newX + finalRadius > LOGICAL_WIDTH) newX = LOGICAL_WIDTH - finalRadius;

                    createMergeEffect(newX, newY, FRUITS[tier].color);
                    
                    const newFruit = createFruit(newX, newY, nextTierIdx);
                    
                    // Crescimento Suave
                    const prevRadius = FRUITS[tier].r;
                    const scaleStart = prevRadius / finalRadius;
                    Body.scale(newFruit, scaleStart, scaleStart);
                    newFruit.isGrowing = true;
                    newFruit.currentScale = scaleStart;
                    newFruit.targetScale = 1.0;
                    newFruit.growSpeed = 0.06; 

                    Body.setVelocity(newFruit, { x: 0, y: 0 });
                    Body.setAngularVelocity(newFruit, 0);

                    World.add(world, newFruit);
                }
            }
        }
    });

    // --- LOOP Lﾃ敵ICO ---
    Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(world);
        let danger = false;
        
        bodies.forEach(body => {
            // Vida
            if (!body.isStatic) body.lifeTime = (body.lifeTime || 0) + 1;

            // Crescimento
            if (body.isGrowing) {
                let scaleFactor = 1 + body.growSpeed;
                body.currentScale *= scaleFactor;
                if (body.currentScale >= body.targetScale) {
                    const correction = body.targetScale / (body.currentScale / scaleFactor);
                    Body.scale(body, correction, correction);
                    body.isGrowing = false; 
                } else {
                    Body.scale(body, scaleFactor, scaleFactor);
                }
            }
            
            // Invulnerabilidade
            if (body.isInvulnerable) {
                if (body.position.y - body.circleRadius > DEADLINE_Y) body.isInvulnerable = false;
                else if (body.lifeTime > 60 && body.speed < 0.2) body.isInvulnerable = false;
            }

            // Anti-bug
            if (body.position.y > LOGICAL_HEIGHT + WALL_THICKNESS) {
                World.remove(world, body);
            }

            // Game Over Check
            if (!body.isStatic && body !== currentBody && body.label !== "ground") {
                if (!body.isInvulnerable) {
                    if (body.position.y < DEADLINE_Y && body.velocity.y < 0.2 && body.velocity.y > -0.2 && !body.isGrowing) {
                        danger = true;
                    }
                }
            }
        });

        if (danger) {
            dangerCounter++;
            if (dangerCounter > 180) { // 3s
                gameOverState = true;
                finalScoreEl.innerText = "Score Final: " + score;
                document.getElementById('game-over').style.display = 'flex';
                Runner.stop(runner);
            }
        } else {
            dangerCounter = 0;
        }
    });

    spawnNext();
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

</script>
</body>
</html>