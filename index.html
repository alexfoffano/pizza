<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Suika Final 360x640</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            position: relative;
        }

        /* 泙 1. O BACKGROUND AGORA FICA AQUI (Tela Cheia) */
        /* Isso garante que nﾃ｣o sobrem espaﾃｧos brancos em telas grandes */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            
            /* Coloque sua imagem aqui se quiser um wallpaper geral */
            /* background-image: url('img/background.png'); */
            background-color: #222; /* Cor de fundo caso nﾃ｣o tenha imagem */
            
            background-size: cover;
            background-position: center;
            z-index: -1;
        }

        #game-container {
            position: relative;
            background: #fffbe6; /* Cor do fundo da ﾃ｡rea de jogo */
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            overflow: hidden;
            
            /* 泙 2. TRAVA DE TAMANHO Mﾃ々IMO */
            /* Garante que o jogo nunca fique maior que o original */
            max-width: 360px;
            max-height: 640px;
            
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255,255,255,0.9);
            padding: 8px;
            border-radius: 12px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 50px;
            z-index: 10;
        }
        
        #ui-label { font-size: 10px; color: #555; font-weight: 800; letter-spacing: 0.5px; }

        #next-fruit-display {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            margin-top: 5px;
            box-shadow: inset 0 -3px 5px rgba(0,0,0,0.2);
        }

        #score-board {
            position: absolute;
            top: 15px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        #score-label { font-size: 11px; color: #999; font-weight: bold; display: block; }
        #score-val { font-size: 36px; font-weight: 900; color: #444; line-height: 1; }

        #game-over {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30,30,30,0.96);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #game-over button {
            margin-top: 25px;
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: #ffcc00;
            color: #222;
            border: none;
            border-radius: 50px;
            text-transform: uppercase;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <div id="game-container">
        <div id="score-board">
            <span id="score-label">SCORE</span>
            <span id="score-val">0</span>
        </div>

        <div id="ui-layer">
            <span id="ui-label">NEXT</span>
            <div id="next-fruit-display"></div>
        </div>

        <div id="game-over">
            <h1 style="font-size:3rem; margin: 0 0 10px 0">GAME OVER</h1>
            <p id="final-score" style="font-size: 1.5rem; color: #aaa;">Score: 0</p>
            <button onclick="location.reload()">Reiniciar</button>
        </div>
    </div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          World = Matter.World,
          Body = Matter.Body;

    // --- CONFIGURAﾃﾃグ ---
    const LOGICAL_WIDTH = 360;  
    const LOGICAL_HEIGHT = 640; 
    const ASPECT_RATIO = LOGICAL_WIDTH / LOGICAL_HEIGHT;
    
    const WALL_THICKNESS = 2000; 
    const FLOOR_OFFSET = 30; 
    const DEADLINE_Y = 130;

    const FRUITS = [
        { r: 16, color: '#F00', score: 2 },
        { r: 24, color: '#F55', score: 4 },
        { r: 32, color: '#A0A', score: 6 },
        { r: 38, color: '#FA0', score: 8 },
        { r: 46, color: '#F80', score: 10 },
        { r: 58, color: '#F00', score: 12 },
        { r: 70, color: '#ED0', score: 14 },
        { r: 84, color: '#FB8', score: 16 },
        { r: 98, color: '#FF0', score: 18 },
        { r: 112,color: '#0F0', score: 20 },
        { r: 126,color: '#080', score: 22 }
    ];

    let score = 0;
    const scoreEl = document.getElementById('score-val');
    const finalScoreEl = document.getElementById('final-score');
    const nextDisplay = document.getElementById('next-fruit-display');
    const container = document.getElementById('game-container');

    // --- 泙 3. RESIZE CONTROLADO ---
    function resizeGame() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const winRatio = winW / winH;
        let newWidth, newHeight;

        if (winRatio > ASPECT_RATIO) {
            // Se a tela for larga (Desktop), usa a altura mﾃ｡xima de 640px
            // Isso forﾃｧa o jogo a ficar pequeno no centro
            newHeight = Math.min(winH, 640); 
            newWidth = newHeight * ASPECT_RATIO;
        } else {
            // Se for mobile estreito, usa a largura
            newWidth = Math.min(winW, 360);
            newHeight = newWidth / ASPECT_RATIO;
        }
        
        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
    }
    window.addEventListener('resize', resizeGame);
    resizeGame();

    // --- SETUP ENGINE ---
    const engine = Engine.create({
        positionIterations: 16, 
        velocityIterations: 16,
        constraintIterations: 4,
        enableSleeping: false 
    });
    const world = engine.world;

    const render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: LOGICAL_WIDTH,
            height: LOGICAL_HEIGHT,
            wireframes: false,
            background: 'transparent',
            pixelRatio: 1
        }
    });

    // --- MUNDO (PAREDES) ---
    const floorY = LOGICAL_HEIGHT + (WALL_THICKNESS / 2) - FLOOR_OFFSET;
    
    const ground = Bodies.rectangle(LOGICAL_WIDTH/2, floorY, LOGICAL_WIDTH + 200, WALL_THICKNESS, { 
        isStatic: true, 
        render: { fillStyle: '#8d6e63' },
        friction: 0.5,      
        restitution: 0.0,   
        label: "ground"
    });

    const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, 
        render: {fillStyle: '#8d6e63'},
        friction: 0.0, 
        restitution: 0.0
    });
    
    const rightWall = Bodies.rectangle(LOGICAL_WIDTH + WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, 
        render: {fillStyle: '#8d6e63'},
        friction: 0.0, 
        restitution: 0.0
    });

    World.add(world, [ground, leftWall, rightWall]);

    // --- 泙 LINHA DE MIRA + GAME OVER ---
    Events.on(render, 'afterRender', function() {
        const ctx = render.context;

        // 1. LINHA DE MIRA (Pontilhada Branca)
        if (currentBody && canDrop && !gameOverState) {
            ctx.beginPath();
            ctx.moveTo(currentBody.position.x, currentBody.position.y);
            ctx.lineTo(currentBody.position.x, LOGICAL_HEIGHT - FLOOR_OFFSET);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
        }

        // 2. LINHA DA MORTE
        ctx.beginPath();
        ctx.moveTo(0, DEADLINE_Y);
        ctx.lineTo(LOGICAL_WIDTH, DEADLINE_Y);
        ctx.strokeStyle = 'rgba(255, 69, 0, 0.6)';
        ctx.lineWidth = 3;
        ctx.setLineDash([12, 10]);
        ctx.stroke();
    });

    // --- CRIAﾃﾃグ DE FRUTAS ---
    function createFruit(x, y, tier, isStatic = false) {
        const cfg = FRUITS[tier];
        
        return Bodies.circle(x, y, cfg.r, {
            label: tier.toString(),
            isStatic: isStatic,
            restitution: 0.05,
            friction: 0.2,     
            frictionAir: 0.02, 
            density: 0.001,    
            render: { fillStyle: cfg.color }
        });
    }

    function createMergeEffect(x, y, color) {
        for (let i = 0; i < 6; i++) {
            const particle = Bodies.circle(x, y, 4, {
                render: { fillStyle: color },
                isSensor: true,
                frictionAir: 0.1
            });
            const angle = Math.random() * Math.PI * 2;
            const speed = 3;
            Body.setVelocity(particle, { x: Math.cos(angle)*speed, y: Math.sin(angle)*speed });
            World.add(world, particle);
            setTimeout(() => World.remove(world, particle), 400);
        }
    }

    // --- GAME LOOP ---
    let currentBody = null;
    let nextTier = 0;
    let canDrop = true;
    let gameOverState = false;

    function pickNextTier() {
        let maxOnField = 0;
        Composite.allBodies(world).forEach(b => {
            if (!b.isStatic && parseInt(b.label) >= 0) maxOnField = Math.max(maxOnField, parseInt(b.label));
        });
        let maxSpawn = 0;
        if (maxOnField >= 2) maxSpawn = 1;
        if (maxOnField >= 4) maxSpawn = 2;
        if (maxOnField >= 6) maxSpawn = 3;

        let pool = [];
        for(let i=0; i <= maxSpawn; i++) {
            for(let k=0; k < 3; k++) pool.push(i);
        }
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function spawnNext() {
        if (gameOverState) return;
        const tier = nextTier;
        nextTier = pickNextTier();
        nextDisplay.style.backgroundColor = FRUITS[nextTier].color;
        
        currentBody = createFruit(LOGICAL_WIDTH / 2, 50, tier, true);
        World.add(world, currentBody);
        canDrop = true;
    }

    function handleInput(clientX) {
        if (!currentBody || !canDrop || gameOverState) return;
        const rect = render.canvas.getBoundingClientRect();
        const scale = LOGICAL_WIDTH / rect.width;
        let x = (clientX - rect.left) * scale;
        
        const r = currentBody.circleRadius;
        if (x < r) x = r;
        if (x > LOGICAL_WIDTH - r) x = LOGICAL_WIDTH - r;
        
        Body.setPosition(currentBody, { x: x, y: 50 });
    }

    function handleRelease() {
        if (!currentBody || !canDrop || gameOverState) return;
        canDrop = false;
        Body.setStatic(currentBody, false);
        currentBody = null; // A mira some aqui
        setTimeout(spawnNext, 500);
    }

    container.addEventListener('mousemove', e => handleInput(e.clientX));
    container.addEventListener('mouseup', handleRelease);
    container.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
    container.addEventListener('touchend', handleRelease);

    // --- COLISﾃグ & MERGE ---
    Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        const processed = new Set(); 

        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA;
            const bodyB = pairs[i].bodyB;
            
            const id = bodyA.id < bodyB.id ? `${bodyA.id}-${bodyB.id}` : `${bodyB.id}-${bodyA.id}`;
            if (processed.has(id)) continue;
            processed.add(id);

            if (bodyA.label === bodyB.label && !bodyA.isStatic && !bodyB.isStatic) {
                const tier = parseInt(bodyA.label);
                score += FRUITS[tier].score;
                scoreEl.innerText = score;

                if (tier < FRUITS.length - 1) {
                    let newX = (bodyA.position.x + bodyB.position.x) / 2;
                    let newY = (bodyA.position.y + bodyB.position.y) / 2;
                    
                    World.remove(world, [bodyA, bodyB]);

                    const nextTierIdx = tier + 1;
                    const finalRadius = FRUITS[nextTierIdx].r;
                    
                    // Clamp
                    const floorYVisual = LOGICAL_HEIGHT - FLOOR_OFFSET;
                    if (newY + finalRadius > floorYVisual) newY = floorYVisual - finalRadius;
                    if (newX - finalRadius < 0) newX = finalRadius;
                    if (newX + finalRadius > LOGICAL_WIDTH) newX = LOGICAL_WIDTH - finalRadius;

                    createMergeEffect(newX, newY, FRUITS[tier].color);
                    
                    const newFruit = createFruit(newX, newY, nextTierIdx);
                    
                    // Crescimento Suave
                    const prevRadius = FRUITS[tier].r;
                    const scaleStart = prevRadius / finalRadius;
                    Body.scale(newFruit, scaleStart, scaleStart);
                    newFruit.isGrowing = true;
                    newFruit.currentScale = scaleStart;
                    newFruit.targetScale = 1.0;
                    newFruit.growSpeed = 0.06; 

                    Body.setVelocity(newFruit, { x: 0, y: 0 });
                    Body.setAngularVelocity(newFruit, 0);

                    World.add(world, newFruit);
                }
            }
        }
    });

    // --- UPDATE LOOP ---
    let dangerCounter = 0;
    
    Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(world);
        let danger = false;
        
        bodies.forEach(body => {
            if (body.isGrowing) {
                let scaleFactor = 1 + body.growSpeed;
                body.currentScale *= scaleFactor;
                if (body.currentScale >= body.targetScale) {
                    const correction = body.targetScale / (body.currentScale / scaleFactor);
                    Body.scale(body, correction, correction);
                    body.isGrowing = false; 
                } else {
                    Body.scale(body, scaleFactor, scaleFactor);
                }
            }
            
            if (body.position.y > LOGICAL_HEIGHT + WALL_THICKNESS) {
                World.remove(world, body); 
            }

            if (!body.isStatic && body !== currentBody && body.label !== "ground") {
                if (body.position.y < DEADLINE_Y && body.velocity.y < 0.2 && body.velocity.y > -0.2 && !body.isGrowing) {
                    danger = true;
                }
            }
        });

        if (danger) {
            dangerCounter++;
            if (dangerCounter > 180) { // 3 Segundos
                gameOverState = true;
                finalScoreEl.innerText = "Score Final: " + score;
                document.getElementById('game-over').style.display = 'flex';
                Runner.stop(runner);
            }
        } else {
            dangerCounter = 0;
        }
    });

    spawnNext();
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

</script>
</body>
</html>
