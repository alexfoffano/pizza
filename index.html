<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Suika Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a; /* Cor de fundo de seguranÃ§a */
            width: 100vw;
            height: 100vh; /* Garante que ocupa a tela toda */
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            position: relative; /* NecessÃ¡rio para o background funcionar */
        }

        /* ðŸŸ¢ CORREÃ‡ÃƒO: Background em tela cheia independente do tamanho do jogo */
        body::before {
            content: "";
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            
            /* Coloque aqui o caminho da sua imagem */
            background-image: url('img/background.png'); 
            
            background-size: cover; /* Estica a imagem para cobrir tudo */
            background-position: center;
            background-repeat: no-repeat;
            z-index: -1; /* Fica atrÃ¡s do jogo */
            
            /* Opcional: Desfoque para destacar o jogo */
            /* filter: blur(5px) brightness(0.6); */
        }

        #game-container {
            position: relative;
            /* Se quiser que o tabuleiro seja transparente para ver o fundo: */
            background: rgba(255, 251, 230, 0.9); /* Bege semi-transparente */
            
            /* Sombra forte para separar o jogo do fundo */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            
            overflow: hidden;
            
            /* Importante para evitar bordas brancas fantasmas */
            display: block; 
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* ðŸŸ¢ TELA DE LOADING */
        #loading-screen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #222;
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #555;
            border-top: 4px solid #FA0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* UI */
        #ui-layer {
            position: absolute; top: 15px; right: 15px;
            background: rgba(255,255,255,0.9); padding: 8px; border-radius: 12px;
            pointer-events: none; display: flex; flex-direction: column; align-items: center;
            min-width: 50px; z-index: 10;
        }
        #ui-label { font-size: 10px; color: #555; font-weight: 800; letter-spacing: 0.5px; }
        #next-fruit-display {
            width: 35px; height: 35px; border-radius: 50%; margin-top: 5px;
            background-size: contain; background-repeat: no-repeat; background-position: center;
        }

        #score-board { position: absolute; top: 15px; left: 20px; pointer-events: none; z-index: 10; }
        #score-label { font-size: 11px; color: #999; font-weight: bold; display: block; }
        #score-val { font-size: 36px; font-weight: 900; color: #444; line-height: 1; text-shadow: 2px 2px 0 #fff; }

        #game-over {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30,30,30,0.96); display: none; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 100;
        }
        #game-over button {
            margin-top: 25px; padding: 15px 40px; font-size: 1.1rem; font-weight: bold;
            cursor: pointer; background: #ffcc00; color: #222; border: none;
            border-radius: 50px; text-transform: uppercase;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
</head>
<body>

    <div id="loading-screen">
        <div class="spinner"></div>
        <div id="loading-text">Carregando Frutas...</div>
    </div>

    <div id="game-container">
        <div id="score-board">
            <span id="score-label">SCORE</span>
            <span id="score-val">0</span>
        </div>

        <div id="ui-layer">
            <span id="ui-label">NEXT</span>
            <div id="next-fruit-display"></div>
        </div>

        <div id="game-over">
            <h1 style="font-size:3rem; margin: 0 0 10px 0">GAME OVER</h1>
            <p id="final-score" style="font-size: 1.5rem; color: #aaa;">Score: 0</p>
            <button onclick="location.reload()">Reiniciar</button>
        </div>
    </div>

<script>
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          World = Matter.World,
          Body = Matter.Body;

    const LOGICAL_WIDTH = 360;  
    const LOGICAL_HEIGHT = 640; 
    const ASPECT_RATIO = LOGICAL_WIDTH / LOGICAL_HEIGHT;
    
    const WALL_THICKNESS = 2000; 
    const FLOOR_OFFSET = 30; 
    const DEADLINE_Y = 130;
    const ART_SIZE = 512; 
    const IMG_PATH = 'img/'; 

    const FRUITS = [
        { r: 16, color: '#F00', score: 2,  img: 'fruit_0.png' },
        { r: 24, color: '#F55', score: 4,  img: 'fruit_1.png' },
        { r: 32, color: '#A0A', score: 6,  img: 'fruit_2.png' },
        { r: 38, color: '#FA0', score: 8,  img: 'fruit_3.png' },
        { r: 46, color: '#F80', score: 10, img: 'fruit_4.png' },
        { r: 58, color: '#F00', score: 12, img: 'fruit_5.png' },
        { r: 70, color: '#ED0', score: 14, img: 'fruit_6.png' },
        { r: 84, color: '#FB8', score: 16, img: 'fruit_7.png' },
        { r: 98, color: '#FF0', score: 18, img: 'fruit_8.png' },
        { r: 112,color: '#0F0', score: 20, img: 'fruit_9.png' },
        { r: 126,color: '#080', score: 22, img: 'fruit_10.png'}
    ];

    let score = 0;
    let dangerCounter = 0;
    const scoreEl = document.getElementById('score-val');
    const finalScoreEl = document.getElementById('final-score');
    const nextDisplay = document.getElementById('next-fruit-display');
    const container = document.getElementById('game-container');
    const loadingScreen = document.getElementById('loading-screen');
    const loadingText = document.getElementById('loading-text');

    // ðŸŸ¢ SISTEMA DE PRELOADER
    function preloadImages(callback) {
        let loadedCount = 0;
        let totalImages = FRUITS.length;
        let errors = 0;

        FRUITS.forEach((fruit, index) => {
            const img = new Image();
            img.src = IMG_PATH + fruit.img;
            
            img.onload = () => {
                loadedCount++;
                loadingText.innerText = `Carregando... ${Math.floor((loadedCount/totalImages)*100)}%`;
                if (loadedCount + errors === totalImages) callback();
            };
            
            img.onerror = () => {
                console.error(`Erro ao carregar: ${fruit.img}`);
                errors++;
                // Mesmo com erro, continuamos para nÃ£o travar o jogo (a fruta ficarÃ¡ com cor sÃ³lida)
                if (loadedCount + errors === totalImages) callback();
            };
        });
    }

    // --- INICIALIZAÃ‡ÃƒO DO JOGO (SÃ³ roda apÃ³s carregar imagens) ---
    function initGame() {
        // Esconde Loading, Mostra Jogo
        loadingScreen.style.opacity = '0';
        setTimeout(() => { loadingScreen.style.display = 'none'; }, 500);
        container.style.opacity = '1';

        resizeGame();
        
        // Inicia Engine
        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);
        
        // Spawn inicial
        spawnNext();
    }

    function resizeGame() {
        // Usa documentElement.clientHeight que Ã© mais seguro em mobile que window.innerHeight
        const winW = window.innerWidth;
        const winH = document.documentElement.clientHeight; 
        const winRatio = winW / winH;
        
        let newWidth, newHeight;
        
        if (winRatio > ASPECT_RATIO) {
            // Tela Ã© mais larga que o jogo (Desktop ou Celular deitado)
            newHeight = winH; // Ocupa toda a altura
            // Limite opcional para desktop nÃ£o ficar gigante, se quiser pode remover o Math.min
            newHeight = Math.min(newHeight, 900); 
            
            newWidth = newHeight * ASPECT_RATIO;
        } else {
            // Tela Ã© mais estreita que o jogo (Celular em pÃ©)
            newWidth = winW; // Ocupa toda a largura
            newHeight = newWidth / ASPECT_RATIO;
        }

        container.style.width = newWidth + 'px';
        container.style.height = newHeight + 'px';
        
        // Centraliza o scroll (ajuda em alguns navegadores mobile)
        window.scrollTo(0, 0);
    }

    // --- ENGINE SETUP ---
    const engine = Engine.create({
        positionIterations: 16,
        velocityIterations: 16,
        constraintIterations: 4,
        enableSleeping: false 
    });
    const world = engine.world;

    const render = Render.create({
        element: container,
        engine: engine,
        options: {
            width: LOGICAL_WIDTH,
            height: LOGICAL_HEIGHT,
            wireframes: false,
            background: 'transparent',
            pixelRatio: 1.5
        }
    });

    // --- MUNDO ---
    const floorY = LOGICAL_HEIGHT + (WALL_THICKNESS / 2) - FLOOR_OFFSET;
    const ground = Bodies.rectangle(LOGICAL_WIDTH/2, floorY, LOGICAL_WIDTH + 200, WALL_THICKNESS, { 
        isStatic: true, render: { fillStyle: '#8d6e63' }, friction: 0.8, frictionStatic: 10, restitution: 0.0, label: "ground"
    });
    const leftWall = Bodies.rectangle(0 - WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, render: {fillStyle: '#8d6e63'}, friction: 0.2, restitution: 0.0 
    });
    const rightWall = Bodies.rectangle(LOGICAL_WIDTH + WALL_THICKNESS/2, LOGICAL_HEIGHT/2, WALL_THICKNESS, LOGICAL_HEIGHT * 3, { 
        isStatic: true, render: {fillStyle: '#8d6e63'}, friction: 0.2, restitution: 0.0 
    });
    World.add(world, [ground, leftWall, rightWall]);

    Events.on(render, 'afterRender', function() {
        const ctx = render.context;
        if (currentBody && canDrop && !gameOverState) {
            ctx.beginPath();
            ctx.moveTo(currentBody.position.x, currentBody.position.y);
            ctx.lineTo(currentBody.position.x, LOGICAL_HEIGHT - FLOOR_OFFSET);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 6]);
            ctx.stroke();
        }
        ctx.beginPath();
        ctx.moveTo(0, DEADLINE_Y);
        ctx.lineTo(LOGICAL_WIDTH, DEADLINE_Y);
        
        if (dangerCounter > 0) {
            const pulse = Math.sin(engine.timing.timestamp * 0.015); 
            const alpha = 0.7 + pulse * 0.3;
            const thickness = 4 + pulse * 1;
            ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
            ctx.lineWidth = thickness;
            ctx.setLineDash([12, 8]); 
            ctx.shadowColor = 'red';
            ctx.shadowBlur = 10;
        } else {
            ctx.strokeStyle = 'rgba(255, 69, 0, 0.4)';
            ctx.lineWidth = 3;
            ctx.setLineDash([12, 10]);
            ctx.shadowBlur = 0;
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
    });

    function createFruit(x, y, tier, isStatic = false) {
        const cfg = FRUITS[tier];
        const scale = (cfg.r * 2) / ART_SIZE;
        const body = Bodies.circle(x, y, cfg.r, {
            label: tier.toString(),
            isStatic: isStatic,
            restitution: 0.05,
            friction: 0.3,
            frictionAir: 0.02,
            density: 0.0015,
            render: { 
                fillStyle: cfg.color,
                sprite: {
                    texture: IMG_PATH + cfg.img,
                    xScale: scale,
                    yScale: scale
                }
            }
        });
        if (isStatic) body.isInvulnerable = true;
        return body;
    }

    function createMergeEffect(x, y, color) {
        for (let i = 0; i < 8; i++) {
            const particle = Bodies.circle(x, y, 5, {
                render: { fillStyle: color },
                isSensor: true,
                frictionAir: 0.05
            });
            const angle = Math.random() * Math.PI * 2;
            const speed = 4 + Math.random()*4;
            Body.setVelocity(particle, { x: Math.cos(angle)*speed, y: Math.sin(angle)*speed });
            World.add(world, particle);
            setTimeout(() => World.remove(world, particle), 450);
        }
    }

    let currentBody = null;
    let nextTier = 0;
    let canDrop = true;
    let gameOverState = false;

    function pickNextTier() {
        let maxOnField = 0;
        Composite.allBodies(world).forEach(b => {
            if (!b.isStatic && parseInt(b.label) >= 0) maxOnField = Math.max(maxOnField, parseInt(b.label));
        });
        let maxSpawn = 0;
        if (maxOnField >= 2) maxSpawn = 1;
        if (maxOnField >= 4) maxSpawn = 2;
        if (maxOnField >= 6) maxSpawn = 3;

        let pool = [];
        for(let i=0; i <= maxSpawn; i++) {
            for(let k=0; k < 3; k++) pool.push(i);
        }
        return pool[Math.floor(Math.random() * pool.length)];
    }

    function spawnNext() {
        if (gameOverState) return;
        const tier = nextTier;
        nextTier = pickNextTier();
        nextDisplay.style.backgroundColor = 'transparent';
        nextDisplay.style.backgroundImage = `url(${IMG_PATH + FRUITS[nextTier].img})`;
        
        currentBody = createFruit(LOGICAL_WIDTH / 2, 50, tier, true);
        World.add(world, currentBody);
        canDrop = true;
    }

    function handleInput(clientX) {
        if (!currentBody || !canDrop || gameOverState) return;
        const rect = render.canvas.getBoundingClientRect();
        const scale = LOGICAL_WIDTH / rect.width;
        let x = (clientX - rect.left) * scale;
        const r = currentBody.circleRadius;
        if (x < r) x = r;
        if (x > LOGICAL_WIDTH - r) x = LOGICAL_WIDTH - r;
        Body.setPosition(currentBody, { x: x, y: 50 });
    }

    function handleRelease() {
        if (!currentBody || !canDrop || gameOverState) return;
        canDrop = false;
        Body.setStatic(currentBody, false);
        currentBody = null;
        setTimeout(spawnNext, 500);
    }

    container.addEventListener('mousemove', e => handleInput(e.clientX));
    container.addEventListener('mouseup', handleRelease);
    container.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX); }, { passive: false });
    container.addEventListener('touchend', handleRelease);

    Events.on(engine, 'collisionStart', (event) => {
        const pairs = event.pairs;
        const processed = new Set(); 

        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA;
            const bodyB = pairs[i].bodyB;
            
            const id = bodyA.id < bodyB.id ? `${bodyA.id}-${bodyB.id}` : `${bodyB.id}-${bodyA.id}`;
            if (processed.has(id)) continue;
            processed.add(id);

            if (bodyA.label === bodyB.label && !bodyA.isStatic && !bodyB.isStatic) {
                const tier = parseInt(bodyA.label);
                score += FRUITS[tier].score;
                scoreEl.innerText = score;

                if (tier < FRUITS.length - 1) {
                    let newX = (bodyA.position.x + bodyB.position.x) / 2;
                    let newY = (bodyA.position.y + bodyB.position.y) / 2;
                    World.remove(world, [bodyA, bodyB]);
                    const nextTierIdx = tier + 1;
                    const finalRadius = FRUITS[nextTierIdx].r;
                    
                    const floorYVisual = LOGICAL_HEIGHT - FLOOR_OFFSET;
                    if (newY + finalRadius > floorYVisual) newY = floorYVisual - finalRadius;
                    if (newX - finalRadius < 0) newX = finalRadius;
                    if (newX + finalRadius > LOGICAL_WIDTH) newX = LOGICAL_WIDTH - finalRadius;

                    createMergeEffect(newX, newY, FRUITS[tier].color);
                    
                    const newFruit = createFruit(newX, newY, nextTierIdx);
                    
                    const prevRadius = FRUITS[tier].r;
                    const scaleStart = prevRadius / finalRadius;
                    Body.scale(newFruit, scaleStart, scaleStart);
                    newFruit.isGrowing = true;
                    newFruit.currentScale = scaleStart;
                    newFruit.targetScale = 1.0;
                    newFruit.growSpeed = 0.06; 
                    Body.setVelocity(newFruit, { x: 0, y: 0 });
                    Body.setAngularVelocity(newFruit, 0);
                    World.add(world, newFruit);
                }
            }
        }
    });

    Events.on(engine, 'beforeUpdate', () => {
        const bodies = Composite.allBodies(world);
        let danger = false;
        
        bodies.forEach(body => {
            if (!body.isStatic) body.lifeTime = (body.lifeTime || 0) + 1;
            if (body.isGrowing) {
                let scaleFactor = 1 + body.growSpeed;
                body.currentScale *= scaleFactor;
                if (body.currentScale >= body.targetScale) {
                    const correction = body.targetScale / (body.currentScale / scaleFactor);
                    Body.scale(body, correction, correction);
                    body.isGrowing = false; 
                } else {
                    Body.scale(body, scaleFactor, scaleFactor);
                }
            }
            if (body.isInvulnerable) {
                if (body.position.y - body.circleRadius > DEADLINE_Y) body.isInvulnerable = false;
                else if (body.lifeTime > 60 && body.speed < 0.2) body.isInvulnerable = false;
            }
            if (body.position.y > LOGICAL_HEIGHT + WALL_THICKNESS) World.remove(world, body);

            if (!body.isStatic && body !== currentBody && body.label !== "ground") {
                if (!body.isInvulnerable) {
                    if (body.position.y < DEADLINE_Y && body.velocity.y < 0.2 && body.velocity.y > -0.2 && !body.isGrowing) {
                        danger = true;
                    }
                }
            }
        });

        if (danger) {
            dangerCounter++;
            if (dangerCounter > 180) { // 3s
                gameOverState = true;
                finalScoreEl.innerText = "Score Final: " + score;
                document.getElementById('game-over').style.display = 'flex';
                Runner.stop(runner);
            }
        } else {
            dangerCounter = 0;
        }
    });

    // ðŸŸ¢ INICIA O PRELOADER
    preloadImages(initGame);

</script>
</body>
</html>

